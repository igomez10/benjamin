/*
Client Portal Web API

Client Poral Web API

API version: 1.0.0
Contact: e@e.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

// CCPBetaAPIService CCPBetaAPI service
type CCPBetaAPIService service

type CCPBetaAPICompleteCCPRequest struct {
	ctx        context.Context
	ApiService *CCPBetaAPIService
	auth       *CompleteCCPRequest
}

func (r CCPBetaAPICompleteCCPRequest) Auth(auth CompleteCCPRequest) CCPBetaAPICompleteCCPRequest {
	r.auth = &auth
	return r
}

func (r CCPBetaAPICompleteCCPRequest) Execute() (*CompleteCCP200Response, *http.Response, error) {
	return r.ApiService.CompleteCCPExecute(r)
}

/*
CompleteCCP Complete CCP Session

Session Token Authentication

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CCPBetaAPICompleteCCPRequest
*/
func (a *CCPBetaAPIService) CompleteCCP(ctx context.Context) CCPBetaAPICompleteCCPRequest {
	return CCPBetaAPICompleteCCPRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CompleteCCP200Response
func (a *CCPBetaAPIService) CompleteCCPExecute(r CCPBetaAPICompleteCCPRequest) (*CompleteCCP200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CompleteCCP200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CCPBetaAPIService.CompleteCCP")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ccp/auth/response"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.auth
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CCPBetaAPIDeleteOrderRequest struct {
	ctx        context.Context
	ApiService *CCPBetaAPIService
	acct       *string
	id         *float32
}

// Account Number
func (r CCPBetaAPIDeleteOrderRequest) Acct(acct string) CCPBetaAPIDeleteOrderRequest {
	r.acct = &acct
	return r
}

// Order Identifier of original submit order
func (r CCPBetaAPIDeleteOrderRequest) Id(id float32) CCPBetaAPIDeleteOrderRequest {
	r.id = &id
	return r
}

func (r CCPBetaAPIDeleteOrderRequest) Execute() (*OrderData, *http.Response, error) {
	return r.ApiService.DeleteOrderExecute(r)
}

/*
DeleteOrder Delete Order

Sends an Order cancellation request. The status of the order can be queried through /ccp/order. Passing arguments as GET is also supported (requires passing action=delete) (GET is meant for development only)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CCPBetaAPIDeleteOrderRequest
*/
func (a *CCPBetaAPIService) DeleteOrder(ctx context.Context) CCPBetaAPIDeleteOrderRequest {
	return CCPBetaAPIDeleteOrderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return OrderData
func (a *CCPBetaAPIService) DeleteOrderExecute(r CCPBetaAPIDeleteOrderRequest) (*OrderData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OrderData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CCPBetaAPIService.DeleteOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ccp/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.acct == nil {
		return localVarReturnValue, nil, reportError("acct is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "acct", r.acct, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CCPBetaAPIGetCCPAccountRequest struct {
	ctx        context.Context
	ApiService *CCPBetaAPIService
}

func (r CCPBetaAPIGetCCPAccountRequest) Execute() (*GetCCPAccount200Response, *http.Response, error) {
	return r.ApiService.GetCCPAccountExecute(r)
}

/*
GetCCPAccount Brokerage Accounts

Provides the list of tradeable accounts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CCPBetaAPIGetCCPAccountRequest
*/
func (a *CCPBetaAPIService) GetCCPAccount(ctx context.Context) CCPBetaAPIGetCCPAccountRequest {
	return CCPBetaAPIGetCCPAccountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetCCPAccount200Response
func (a *CCPBetaAPIService) GetCCPAccountExecute(r CCPBetaAPIGetCCPAccountRequest) (*GetCCPAccount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetCCPAccount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CCPBetaAPIService.GetCCPAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ccp/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CCPBetaAPIGetCCPOrdersRequest struct {
	ctx        context.Context
	ApiService *CCPBetaAPIService
	acct       *string
	cancelled  *bool
}

// User Account
func (r CCPBetaAPIGetCCPOrdersRequest) Acct(acct string) CCPBetaAPIGetCCPOrdersRequest {
	r.acct = &acct
	return r
}

// Return only Rejected or Cancelled orders since today midnight
func (r CCPBetaAPIGetCCPOrdersRequest) Cancelled(cancelled bool) CCPBetaAPIGetCCPOrdersRequest {
	r.cancelled = &cancelled
	return r
}

func (r CCPBetaAPIGetCCPOrdersRequest) Execute() (*GetCCPOrders200Response, *http.Response, error) {
	return r.ApiService.GetCCPOrdersExecute(r)
}

/*
GetCCPOrders Order Status

Get status for all orders

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CCPBetaAPIGetCCPOrdersRequest
*/
func (a *CCPBetaAPIService) GetCCPOrders(ctx context.Context) CCPBetaAPIGetCCPOrdersRequest {
	return CCPBetaAPIGetCCPOrdersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetCCPOrders200Response
func (a *CCPBetaAPIService) GetCCPOrdersExecute(r CCPBetaAPIGetCCPOrdersRequest) (*GetCCPOrders200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetCCPOrders200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CCPBetaAPIService.GetCCPOrders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ccp/orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.acct == nil {
		return localVarReturnValue, nil, reportError("acct is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "acct", r.acct, "")
	if r.cancelled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cancelled", r.cancelled, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CCPBetaAPIGetCCPPositionsRequest struct {
	ctx        context.Context
	ApiService *CCPBetaAPIService
}

func (r CCPBetaAPIGetCCPPositionsRequest) Execute() (*PositionData, *http.Response, error) {
	return r.ApiService.GetCCPPositionsExecute(r)
}

/*
GetCCPPositions Positions

List of positions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CCPBetaAPIGetCCPPositionsRequest
*/
func (a *CCPBetaAPIService) GetCCPPositions(ctx context.Context) CCPBetaAPIGetCCPPositionsRequest {
	return CCPBetaAPIGetCCPPositionsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PositionData
func (a *CCPBetaAPIService) GetCCPPositionsExecute(r CCPBetaAPIGetCCPPositionsRequest) (*PositionData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PositionData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CCPBetaAPIService.GetCCPPositions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ccp/positions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CCPBetaAPIGetCCPStatusRequest struct {
	ctx        context.Context
	ApiService *CCPBetaAPIService
}

func (r CCPBetaAPIGetCCPStatusRequest) Execute() (*GetCCPStatus200Response, *http.Response, error) {
	return r.ApiService.GetCCPStatusExecute(r)
}

/*
GetCCPStatus CCP Status

Provide the current CCP session status. When using the Gateway this endpoint will also initiate a brokerage session to CCP by sending /auth/init and response.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CCPBetaAPIGetCCPStatusRequest
*/
func (a *CCPBetaAPIService) GetCCPStatus(ctx context.Context) CCPBetaAPIGetCCPStatusRequest {
	return CCPBetaAPIGetCCPStatusRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetCCPStatus200Response
func (a *CCPBetaAPIService) GetCCPStatusExecute(r CCPBetaAPIGetCCPStatusRequest) (*GetCCPStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetCCPStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CCPBetaAPIService.GetCCPStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ccp/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CCPBetaAPIGetCCPTradesRequest struct {
	ctx        context.Context
	ApiService *CCPBetaAPIService
	from       *string
	to         *string
}

// From Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..)
func (r CCPBetaAPIGetCCPTradesRequest) From(from string) CCPBetaAPIGetCCPTradesRequest {
	r.from = &from
	return r
}

// To Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..). To value should be bigger than from value.
func (r CCPBetaAPIGetCCPTradesRequest) To(to string) CCPBetaAPIGetCCPTradesRequest {
	r.to = &to
	return r
}

func (r CCPBetaAPIGetCCPTradesRequest) Execute() (*GetCCPOrders200Response, *http.Response, error) {
	return r.ApiService.GetCCPTradesExecute(r)
}

/*
GetCCPTrades Trades

Get a list of Trades, by default, the list is from today midnight to Date.now().

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CCPBetaAPIGetCCPTradesRequest
*/
func (a *CCPBetaAPIService) GetCCPTrades(ctx context.Context) CCPBetaAPIGetCCPTradesRequest {
	return CCPBetaAPIGetCCPTradesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetCCPOrders200Response
func (a *CCPBetaAPIService) GetCCPTradesExecute(r CCPBetaAPIGetCCPTradesRequest) (*GetCCPOrders200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetCCPOrders200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CCPBetaAPIService.GetCCPTrades")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ccp/trades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CCPBetaAPIInitCCPRequest struct {
	ctx        context.Context
	ApiService *CCPBetaAPIService
	compete    *bool
	locale     *string
	mac        *string
	machineId  *string
	username   *string
}

// Allow competing CCP session to run
func (r CCPBetaAPIInitCCPRequest) Compete(compete bool) CCPBetaAPIInitCCPRequest {
	r.compete = &compete
	return r
}

// Concatenate value for language and region, set to \\\&quot;en_US\\\&quot;
func (r CCPBetaAPIInitCCPRequest) Locale(locale string) CCPBetaAPIInitCCPRequest {
	r.locale = &locale
	return r
}

// Local MAC Address
func (r CCPBetaAPIInitCCPRequest) Mac(mac string) CCPBetaAPIInitCCPRequest {
	r.mac = &mac
	return r
}

// Local machine ID
func (r CCPBetaAPIInitCCPRequest) MachineId(machineId string) CCPBetaAPIInitCCPRequest {
	r.machineId = &machineId
	return r
}

// Login user, set to dash \\\&quot;-\\\&quot;
func (r CCPBetaAPIInitCCPRequest) Username(username string) CCPBetaAPIInitCCPRequest {
	r.username = &username
	return r
}

func (r CCPBetaAPIInitCCPRequest) Execute() (*InitCCP200Response, *http.Response, error) {
	return r.ApiService.InitCCPExecute(r)
}

/*
InitCCP Start CCP Session

Initiate a brokerage session to CCP. Only one brokerage session type can run at a time. If an existing brokerage session to iServer is running then call the endpoint /logout first. Note at this time only order management is possible from CCP session, market data and scanner endpoints can't be used since they are only available from iServer session. Work is in progress to provide new CCP endpoints for market data and scanners.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CCPBetaAPIInitCCPRequest
*/
func (a *CCPBetaAPIService) InitCCP(ctx context.Context) CCPBetaAPIInitCCPRequest {
	return CCPBetaAPIInitCCPRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return InitCCP200Response
func (a *CCPBetaAPIService) InitCCPExecute(r CCPBetaAPIInitCCPRequest) (*InitCCP200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InitCCP200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CCPBetaAPIService.InitCCP")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ccp/auth/init"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.compete != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "compete", r.compete, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "locale", r.locale, "")
	}
	if r.mac != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "mac", r.mac, "")
	}
	if r.machineId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "machineId", r.machineId, "")
	}
	if r.username != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "username", r.username, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CCPBetaAPISubmitOrderRequest struct {
	ctx        context.Context
	ApiService *CCPBetaAPIService
	acct       *string
	conid      *float32
	ccy        *string
	exchange   *string
	qty        *float32
	type_      *string
	side       *string
	price      *float32
	tif        *string
}

// User Account
func (r CCPBetaAPISubmitOrderRequest) Acct(acct string) CCPBetaAPISubmitOrderRequest {
	r.acct = &acct
	return r
}

// Contract identifier from IBKR&#39;s database.
func (r CCPBetaAPISubmitOrderRequest) Conid(conid float32) CCPBetaAPISubmitOrderRequest {
	r.conid = &conid
	return r
}

// Contract Currency
func (r CCPBetaAPISubmitOrderRequest) Ccy(ccy string) CCPBetaAPISubmitOrderRequest {
	r.ccy = &ccy
	return r
}

// Exchange
func (r CCPBetaAPISubmitOrderRequest) Exchange(exchange string) CCPBetaAPISubmitOrderRequest {
	r.exchange = &exchange
	return r
}

// Order Quantity
func (r CCPBetaAPISubmitOrderRequest) Qty(qty float32) CCPBetaAPISubmitOrderRequest {
	r.qty = &qty
	return r
}

// Order Price; required if order type is limit
func (r CCPBetaAPISubmitOrderRequest) Type_(type_ string) CCPBetaAPISubmitOrderRequest {
	r.type_ = &type_
	return r
}

// Side
func (r CCPBetaAPISubmitOrderRequest) Side(side string) CCPBetaAPISubmitOrderRequest {
	r.side = &side
	return r
}

// Order Price; required if order type is limit
func (r CCPBetaAPISubmitOrderRequest) Price(price float32) CCPBetaAPISubmitOrderRequest {
	r.price = &price
	return r
}

// Time in Force
func (r CCPBetaAPISubmitOrderRequest) Tif(tif string) CCPBetaAPISubmitOrderRequest {
	r.tif = &tif
	return r
}

func (r CCPBetaAPISubmitOrderRequest) Execute() (*OrderData, *http.Response, error) {
	return r.ApiService.SubmitOrderExecute(r)
}

/*
SubmitOrder Submit Order

Submits an Order.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CCPBetaAPISubmitOrderRequest
*/
func (a *CCPBetaAPIService) SubmitOrder(ctx context.Context) CCPBetaAPISubmitOrderRequest {
	return CCPBetaAPISubmitOrderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return OrderData
func (a *CCPBetaAPIService) SubmitOrderExecute(r CCPBetaAPISubmitOrderRequest) (*OrderData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OrderData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CCPBetaAPIService.SubmitOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ccp/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.acct == nil {
		return localVarReturnValue, nil, reportError("acct is required and must be specified")
	}
	if r.conid == nil {
		return localVarReturnValue, nil, reportError("conid is required and must be specified")
	}
	if r.ccy == nil {
		return localVarReturnValue, nil, reportError("ccy is required and must be specified")
	}
	if r.exchange == nil {
		return localVarReturnValue, nil, reportError("exchange is required and must be specified")
	}
	if r.qty == nil {
		return localVarReturnValue, nil, reportError("qty is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "acct", r.acct, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "conid", r.conid, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ccy", r.ccy, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "qty", r.qty, "")
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.side != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "side", r.side, "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "price", r.price, "")
	}
	if r.tif != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tif", r.tif, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CCPBetaAPIUpdateOrderRequest struct {
	ctx        context.Context
	ApiService *CCPBetaAPIService
	acct       *string
	id         *float32
}

// User Account
func (r CCPBetaAPIUpdateOrderRequest) Acct(acct string) CCPBetaAPIUpdateOrderRequest {
	r.acct = &acct
	return r
}

// Order ID to be modified
func (r CCPBetaAPIUpdateOrderRequest) Id(id float32) CCPBetaAPIUpdateOrderRequest {
	r.id = &id
	return r
}

func (r CCPBetaAPIUpdateOrderRequest) Execute() (*OrderData, *http.Response, error) {
	return r.ApiService.UpdateOrderExecute(r)
}

/*
UpdateOrder Update Order

Updates an Order. Updating an order requires the same arguments as placing an order besides the conid. Note: The status of the order can be queried through GET /ccp/order.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CCPBetaAPIUpdateOrderRequest
*/
func (a *CCPBetaAPIService) UpdateOrder(ctx context.Context) CCPBetaAPIUpdateOrderRequest {
	return CCPBetaAPIUpdateOrderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return OrderData
func (a *CCPBetaAPIService) UpdateOrderExecute(r CCPBetaAPIUpdateOrderRequest) (*OrderData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OrderData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CCPBetaAPIService.UpdateOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ccp/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.acct == nil {
		return localVarReturnValue, nil, reportError("acct is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "acct", r.acct, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
