/*
Client Portal Web API

Client Poral Web API

API version: 1.0.0
Contact: e@e.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// MarketDataAPIService MarketDataAPI service
type MarketDataAPIService service

type MarketDataAPIGetHistoryRequest struct {
	ctx        context.Context
	ApiService *MarketDataAPIService
	conid      *int32
	period     *string
	bar        *string
	outsideRth *bool
}

// contract id
func (r MarketDataAPIGetHistoryRequest) Conid(conid int32) MarketDataAPIGetHistoryRequest {
	r.conid = &conid
	return r
}

// Time period for history request.    * min: Minutes   * h: Hours   * d: Days   * w: Weeks   * m: Months   * y: Years
func (r MarketDataAPIGetHistoryRequest) Period(period string) MarketDataAPIGetHistoryRequest {
	r.period = &period
	return r
}

// Duration of time for each candlestick bar.   * min: Minutes   * h: Hours   * d: Days   * w: Weeks   * m: Months
func (r MarketDataAPIGetHistoryRequest) Bar(bar string) MarketDataAPIGetHistoryRequest {
	r.bar = &bar
	return r
}

// For contracts that support it, will determine if history data includes outside of regular trading hours.
func (r MarketDataAPIGetHistoryRequest) OutsideRth(outsideRth bool) MarketDataAPIGetHistoryRequest {
	r.outsideRth = &outsideRth
	return r
}

func (r MarketDataAPIGetHistoryRequest) Execute() (*HistoryResult, *http.Response, error) {
	return r.ApiService.GetHistoryExecute(r)
}

/*
GetHistory Market Data History (Beta)

Using a direct connection to the market data farm, will provide a list of historical market data for given conid.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return MarketDataAPIGetHistoryRequest
*/
func (a *MarketDataAPIService) GetHistory(ctx context.Context) MarketDataAPIGetHistoryRequest {
	return MarketDataAPIGetHistoryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return HistoryResult
func (a *MarketDataAPIService) GetHistoryExecute(r MarketDataAPIGetHistoryRequest) (*HistoryResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HistoryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.GetHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hmds/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conid == nil {
		return localVarReturnValue, nil, reportError("conid is required and must be specified")
	}
	if r.period == nil {
		return localVarReturnValue, nil, reportError("period is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "conid", r.conid, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "")
	if r.bar != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bar", r.bar, "")
	}
	if r.outsideRth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outsideRth", r.outsideRth, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIGetSnapshotRequest struct {
	ctx        context.Context
	ApiService *MarketDataAPIService
	conids     *string
	fields     *[]float32
}

// List of conids comma separated. Optional exchange and instrument type can be specified.   * conid: IBKR Contract Identifier   * exchange: Exchange or venue   * instrType: Instrument Type supported values: CS (Stocks), OPT (Options), FUT (Futures), FOP (Future Options), WAR (Warrants), BOND (Bonds), FUND (Mutual Funds), CASH (Forex), CFD (Contract for difference), IND (Index)
func (r MarketDataAPIGetSnapshotRequest) Conids(conids string) MarketDataAPIGetSnapshotRequest {
	r.conids = &conids
	return r
}

// list of fields separated by comma
func (r MarketDataAPIGetSnapshotRequest) Fields(fields []float32) MarketDataAPIGetSnapshotRequest {
	r.fields = &fields
	return r
}

func (r MarketDataAPIGetSnapshotRequest) Execute() (*MarketData, *http.Response, error) {
	return r.ApiService.GetSnapshotExecute(r)
}

/*
GetSnapshot Market Data Snapshot (Beta)

Get a snapshot of Market Data for the given conid(s).See response for a list of available fields that can be requested from the fields argument.
Must be connected to a brokerage session before can query snapshot data.
First /snapshot endpoint call for given conid(s) will initiate the market data request, make an additional request to receive field values back.
To receive all available fields the /snapshot endpoint will need to be called several times.
To receive streaming market data the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return MarketDataAPIGetSnapshotRequest
*/
func (a *MarketDataAPIService) GetSnapshot(ctx context.Context) MarketDataAPIGetSnapshotRequest {
	return MarketDataAPIGetSnapshotRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MarketData
func (a *MarketDataAPIService) GetSnapshotExecute(r MarketDataAPIGetSnapshotRequest) (*MarketData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MarketData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.GetSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/md/snapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conids == nil {
		return localVarReturnValue, nil, reportError("conids is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "conids", r.conids, "")
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIIserverMarketdataConidUnsubscribeGetRequest struct {
	ctx        context.Context
	ApiService *MarketDataAPIService
	conid      string
}

func (r MarketDataAPIIserverMarketdataConidUnsubscribeGetRequest) Execute() (*IserverMarketdataConidUnsubscribeGet200Response, *http.Response, error) {
	return r.ApiService.IserverMarketdataConidUnsubscribeGetExecute(r)
}

/*
IserverMarketdataConidUnsubscribeGet Market Data Cancel (Single)

Cancel market data for given conid. To cancel all market data request(s), see /iserver/marketdata/unsubscribeall.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param conid contract id
	@return MarketDataAPIIserverMarketdataConidUnsubscribeGetRequest
*/
func (a *MarketDataAPIService) IserverMarketdataConidUnsubscribeGet(ctx context.Context, conid string) MarketDataAPIIserverMarketdataConidUnsubscribeGetRequest {
	return MarketDataAPIIserverMarketdataConidUnsubscribeGetRequest{
		ApiService: a,
		ctx:        ctx,
		conid:      conid,
	}
}

// Execute executes the request
//
//	@return IserverMarketdataConidUnsubscribeGet200Response
func (a *MarketDataAPIService) IserverMarketdataConidUnsubscribeGetExecute(r MarketDataAPIIserverMarketdataConidUnsubscribeGetRequest) (*IserverMarketdataConidUnsubscribeGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IserverMarketdataConidUnsubscribeGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.IserverMarketdataConidUnsubscribeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iserver/marketdata/{conid}/unsubscribe"
	localVarPath = strings.Replace(localVarPath, "{"+"conid"+"}", url.PathEscape(parameterValueToString(r.conid, "conid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIIserverMarketdataHistoryGetRequest struct {
	ctx        context.Context
	ApiService *MarketDataAPIService
	conid      *string
	period     *string
	exchange   *string
	bar        *string
	outsideRth *bool
}

// contract id
func (r MarketDataAPIIserverMarketdataHistoryGetRequest) Conid(conid string) MarketDataAPIIserverMarketdataHistoryGetRequest {
	r.conid = &conid
	return r
}

// available time period-- {1-30}min, {1-8}h, {1-1000}d, {1-792}w, {1-182}m, {1-15}y
func (r MarketDataAPIIserverMarketdataHistoryGetRequest) Period(period string) MarketDataAPIIserverMarketdataHistoryGetRequest {
	r.period = &period
	return r
}

// Exchange of the conid (e.g. ISLAND, NYSE, etc.). Default value is empty which corresponds to primary exchange of the conid.
func (r MarketDataAPIIserverMarketdataHistoryGetRequest) Exchange(exchange string) MarketDataAPIIserverMarketdataHistoryGetRequest {
	r.exchange = &exchange
	return r
}

// possible value-- 1min, 2min, 3min, 5min, 10min, 15min, 30min, 1h, 2h, 3h, 4h, 8h, 1d, 1w, 1m
func (r MarketDataAPIIserverMarketdataHistoryGetRequest) Bar(bar string) MarketDataAPIIserverMarketdataHistoryGetRequest {
	r.bar = &bar
	return r
}

// For contracts that support it, will determine if historical data includes outside of regular trading hours.
func (r MarketDataAPIIserverMarketdataHistoryGetRequest) OutsideRth(outsideRth bool) MarketDataAPIIserverMarketdataHistoryGetRequest {
	r.outsideRth = &outsideRth
	return r
}

func (r MarketDataAPIIserverMarketdataHistoryGetRequest) Execute() (*HistoryData, *http.Response, error) {
	return r.ApiService.IserverMarketdataHistoryGetExecute(r)
}

/*
IserverMarketdataHistoryGet Market Data History

Get historical market Data for given conid, length of data is controlled by 'period' and 'bar'.
Formatted as: min=minute, h=hour, d=day, w=week, m=month, y=year
e.g. period =1y with bar =1w returns 52 data points (Max of 1000 data points supported).
**Note**: There's a limit of 5 concurrent requests. Excessive requests will return a 'Too many requests' status 429 response.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return MarketDataAPIIserverMarketdataHistoryGetRequest
*/
func (a *MarketDataAPIService) IserverMarketdataHistoryGet(ctx context.Context) MarketDataAPIIserverMarketdataHistoryGetRequest {
	return MarketDataAPIIserverMarketdataHistoryGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return HistoryData
func (a *MarketDataAPIService) IserverMarketdataHistoryGetExecute(r MarketDataAPIIserverMarketdataHistoryGetRequest) (*HistoryData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HistoryData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.IserverMarketdataHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iserver/marketdata/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conid == nil {
		return localVarReturnValue, nil, reportError("conid is required and must be specified")
	}
	if r.period == nil {
		return localVarReturnValue, nil, reportError("period is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "conid", r.conid, "")
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "")
	if r.bar != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bar", r.bar, "")
	}
	if r.outsideRth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outsideRth", r.outsideRth, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetFutures500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v SystemError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIIserverMarketdataSnapshotGetRequest struct {
	ctx        context.Context
	ApiService *MarketDataAPIService
	conids     *string
	since      *int32
	fields     *string
}

// list of conids separated by comma
func (r MarketDataAPIIserverMarketdataSnapshotGetRequest) Conids(conids string) MarketDataAPIIserverMarketdataSnapshotGetRequest {
	r.conids = &conids
	return r
}

// time period since which updates are required. uses epoch time with milliseconds.
func (r MarketDataAPIIserverMarketdataSnapshotGetRequest) Since(since int32) MarketDataAPIIserverMarketdataSnapshotGetRequest {
	r.since = &since
	return r
}

// list of fields separated by comma
func (r MarketDataAPIIserverMarketdataSnapshotGetRequest) Fields(fields string) MarketDataAPIIserverMarketdataSnapshotGetRequest {
	r.fields = &fields
	return r
}

func (r MarketDataAPIIserverMarketdataSnapshotGetRequest) Execute() ([]IserverMarketdataSnapshotGet200ResponseInner, *http.Response, error) {
	return r.ApiService.IserverMarketdataSnapshotGetExecute(r)
}

/*
IserverMarketdataSnapshotGet Market Data

Get Market Data for the given conid(s). The endpoint will return by default bid, ask, last, change, change pct, close, listing exchange.
See response fields for a list of available fields that can be request via fields argument.
The endpoint /iserver/accounts must be called prior to /iserver/marketdata/snapshot.
For derivative contracts the endpoint /iserver/secdef/search must be called first.
First /snapshot endpoint call for given conid will initiate the market data request.
To receive all available fields the /snapshot endpoint will need to be called several times.
To receive streaming market data the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return MarketDataAPIIserverMarketdataSnapshotGetRequest
*/
func (a *MarketDataAPIService) IserverMarketdataSnapshotGet(ctx context.Context) MarketDataAPIIserverMarketdataSnapshotGetRequest {
	return MarketDataAPIIserverMarketdataSnapshotGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []IserverMarketdataSnapshotGet200ResponseInner
func (a *MarketDataAPIService) IserverMarketdataSnapshotGetExecute(r MarketDataAPIIserverMarketdataSnapshotGetRequest) ([]IserverMarketdataSnapshotGet200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []IserverMarketdataSnapshotGet200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.IserverMarketdataSnapshotGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iserver/marketdata/snapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conids == nil {
		return localVarReturnValue, nil, reportError("conids is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "conids", r.conids, "")
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v IserverMarketdataSnapshotGet400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIIserverMarketdataUnsubscribeallGetRequest struct {
	ctx        context.Context
	ApiService *MarketDataAPIService
}

func (r MarketDataAPIIserverMarketdataUnsubscribeallGetRequest) Execute() (*IserverMarketdataUnsubscribeallGet200Response, *http.Response, error) {
	return r.ApiService.IserverMarketdataUnsubscribeallGetExecute(r)
}

/*
IserverMarketdataUnsubscribeallGet Market Data Cancel (All)

Cancel all market data request(s). To cancel market data for given conid, see /iserver/marketdata/{conid}/unsubscribe.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return MarketDataAPIIserverMarketdataUnsubscribeallGetRequest
*/
func (a *MarketDataAPIService) IserverMarketdataUnsubscribeallGet(ctx context.Context) MarketDataAPIIserverMarketdataUnsubscribeallGetRequest {
	return MarketDataAPIIserverMarketdataUnsubscribeallGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return IserverMarketdataUnsubscribeallGet200Response
func (a *MarketDataAPIService) IserverMarketdataUnsubscribeallGetExecute(r MarketDataAPIIserverMarketdataUnsubscribeallGetRequest) (*IserverMarketdataUnsubscribeallGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IserverMarketdataUnsubscribeallGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.IserverMarketdataUnsubscribeallGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iserver/marketdata/unsubscribeall"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
