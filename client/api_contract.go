/*
Client Portal Web API

Client Poral Web API

API version: 1.0.0
Contact: e@e.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// ContractAPIService ContractAPI service
type ContractAPIService service

type ContractAPIGetFuturesRequest struct {
	ctx        context.Context
	ApiService *ContractAPIService
	symbols    *string
}

// list of case-sensitive symbols separated by comma
func (r ContractAPIGetFuturesRequest) Symbols(symbols string) ContractAPIGetFuturesRequest {
	r.symbols = &symbols
	return r
}

func (r ContractAPIGetFuturesRequest) Execute() (*GetFutures200Response, *http.Response, error) {
	return r.ApiService.GetFuturesExecute(r)
}

/*
GetFutures Security Futures by Symbol

Returns a list of non-expired future contracts for given symbol(s)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ContractAPIGetFuturesRequest
*/
func (a *ContractAPIService) GetFutures(ctx context.Context) ContractAPIGetFuturesRequest {
	return ContractAPIGetFuturesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetFutures200Response
func (a *ContractAPIService) GetFuturesExecute(r ContractAPIGetFuturesRequest) (*GetFutures200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetFutures200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractAPIService.GetFutures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/trsrv/futures"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbols == nil {
		return localVarReturnValue, nil, reportError("symbols is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbols", r.symbols, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetFutures500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ContractAPIGetSecdefRequest struct {
	ctx        context.Context
	ApiService *ContractAPIService
	body       *GetSecdefRequest
}

// request body
func (r ContractAPIGetSecdefRequest) Body(body GetSecdefRequest) ContractAPIGetSecdefRequest {
	r.body = &body
	return r
}

func (r ContractAPIGetSecdefRequest) Execute() ([]SecdefInner, *http.Response, error) {
	return r.ApiService.GetSecdefExecute(r)
}

/*
GetSecdef Secdef by Conid

Returns a list of security definitions for the given conids

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ContractAPIGetSecdefRequest
*/
func (a *ContractAPIService) GetSecdef(ctx context.Context) ContractAPIGetSecdefRequest {
	return ContractAPIGetSecdefRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []SecdefInner
func (a *ContractAPIService) GetSecdefExecute(r ContractAPIGetSecdefRequest) ([]SecdefInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []SecdefInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractAPIService.GetSecdef")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/trsrv/secdef"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ContractAPIGetSecdefScheduleRequest struct {
	ctx            context.Context
	ApiService     *ContractAPIService
	assetClass     *string
	symbol         *string
	exchange       *string
	exchangeFilter *string
}

// specify the asset class of the contract. Available values-- Stock: STK, Option: OPT, Future: FUT, Contract For Difference: CFD, Warrant: WAR, Forex: SWP, Mutual Fund: FND, Bond: BND, Inter-Commodity Spreads: ICS
func (r ContractAPIGetSecdefScheduleRequest) AssetClass(assetClass string) ContractAPIGetSecdefScheduleRequest {
	r.assetClass = &assetClass
	return r
}

// Underlying Symbol for specified contract, for example &#39;AAPL&#39; for US Stock - Apple Inc.
func (r ContractAPIGetSecdefScheduleRequest) Symbol(symbol string) ContractAPIGetSecdefScheduleRequest {
	r.symbol = &symbol
	return r
}

// Native exchange for contract, for example &#39;NASDAQ&#39; for US Stock - Apple Inc.
func (r ContractAPIGetSecdefScheduleRequest) Exchange(exchange string) ContractAPIGetSecdefScheduleRequest {
	r.exchange = &exchange
	return r
}

// Response only returns trading schedule for specified exchange
func (r ContractAPIGetSecdefScheduleRequest) ExchangeFilter(exchangeFilter string) ContractAPIGetSecdefScheduleRequest {
	r.exchangeFilter = &exchangeFilter
	return r
}

func (r ContractAPIGetSecdefScheduleRequest) Execute() (*GetSecdefSchedule200Response, *http.Response, error) {
	return r.ApiService.GetSecdefScheduleExecute(r)
}

/*
GetSecdefSchedule Get trading schedule for symbol

Returns the trading schedule up to a month for the requested contract

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ContractAPIGetSecdefScheduleRequest
*/
func (a *ContractAPIService) GetSecdefSchedule(ctx context.Context) ContractAPIGetSecdefScheduleRequest {
	return ContractAPIGetSecdefScheduleRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetSecdefSchedule200Response
func (a *ContractAPIService) GetSecdefScheduleExecute(r ContractAPIGetSecdefScheduleRequest) (*GetSecdefSchedule200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetSecdefSchedule200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractAPIService.GetSecdefSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/trsrv/secdef/schedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assetClass == nil {
		return localVarReturnValue, nil, reportError("assetClass is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "assetClass", r.assetClass, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "")
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "")
	}
	if r.exchangeFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeFilter", r.exchangeFilter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ContractAPIGetStocksRequest struct {
	ctx        context.Context
	ApiService *ContractAPIService
	symbols    *string
}

// list of upper-sensitive symbols separated by comma
func (r ContractAPIGetStocksRequest) Symbols(symbols string) ContractAPIGetStocksRequest {
	r.symbols = &symbols
	return r
}

func (r ContractAPIGetStocksRequest) Execute() (*GetStocks200Response, *http.Response, error) {
	return r.ApiService.GetStocksExecute(r)
}

/*
GetStocks Security Stocks by Symbol

Returns an object contains all stock contracts for given symbol(s)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ContractAPIGetStocksRequest
*/
func (a *ContractAPIService) GetStocks(ctx context.Context) ContractAPIGetStocksRequest {
	return ContractAPIGetStocksRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetStocks200Response
func (a *ContractAPIService) GetStocksExecute(r ContractAPIGetStocksRequest) (*GetStocks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetStocks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractAPIService.GetStocks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/trsrv/stocks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbols == nil {
		return localVarReturnValue, nil, reportError("symbols is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbols", r.symbols, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetFutures500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ContractAPIIserverContractConidAlgosGetRequest struct {
	ctx            context.Context
	ApiService     *ContractAPIService
	conid          string
	algos          *string
	addDescription *string
	addParams      *string
}

// List of algo ids delimited by \&quot;;\&quot; to filter by. Max of 8 algos ids can be specified.
func (r ContractAPIIserverContractConidAlgosGetRequest) Algos(algos string) ContractAPIIserverContractConidAlgosGetRequest {
	r.algos = &algos
	return r
}

// Whether or not to add algo descriptions to response. Set to 1 for yes, 0 for no.
func (r ContractAPIIserverContractConidAlgosGetRequest) AddDescription(addDescription string) ContractAPIIserverContractConidAlgosGetRequest {
	r.addDescription = &addDescription
	return r
}

// Whether or not to show algo parameters.  Set to 1 for yes, 0 for no.
func (r ContractAPIIserverContractConidAlgosGetRequest) AddParams(addParams string) ContractAPIIserverContractConidAlgosGetRequest {
	r.addParams = &addParams
	return r
}

func (r ContractAPIIserverContractConidAlgosGetRequest) Execute() ([]IserverContractConidAlgosGet200ResponseInner, *http.Response, error) {
	return r.ApiService.IserverContractConidAlgosGetExecute(r)
}

/*
IserverContractConidAlgosGet IB Algo Params

Returns supported IB Algos for contract. Must be called a second time to query the list of available parameters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param conid IBKR contract identifier
	@return ContractAPIIserverContractConidAlgosGetRequest
*/
func (a *ContractAPIService) IserverContractConidAlgosGet(ctx context.Context, conid string) ContractAPIIserverContractConidAlgosGetRequest {
	return ContractAPIIserverContractConidAlgosGetRequest{
		ApiService: a,
		ctx:        ctx,
		conid:      conid,
	}
}

// Execute executes the request
//
//	@return []IserverContractConidAlgosGet200ResponseInner
func (a *ContractAPIService) IserverContractConidAlgosGetExecute(r ContractAPIIserverContractConidAlgosGetRequest) ([]IserverContractConidAlgosGet200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []IserverContractConidAlgosGet200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractAPIService.IserverContractConidAlgosGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iserver/contract/{conid}/algos"
	localVarPath = strings.Replace(localVarPath, "{"+"conid"+"}", url.PathEscape(parameterValueToString(r.conid, "conid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.algos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "algos", r.algos, "")
	}
	if r.addDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addDescription", r.addDescription, "")
	}
	if r.addParams != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addParams", r.addParams, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ContractAPIIserverContractConidInfoAndRulesGetRequest struct {
	ctx        context.Context
	ApiService *ContractAPIService
	conid      string
	isBuy      *bool
}

// Side of the market rules apply too. Set to **true** for Buy Orders, set to **false** for Sell Orders
func (r ContractAPIIserverContractConidInfoAndRulesGetRequest) IsBuy(isBuy bool) ContractAPIIserverContractConidInfoAndRulesGetRequest {
	r.isBuy = &isBuy
	return r
}

func (r ContractAPIIserverContractConidInfoAndRulesGetRequest) Execute() (*IserverContractConidInfoAndRulesGet200Response, *http.Response, error) {
	return r.ApiService.IserverContractConidInfoAndRulesGetExecute(r)
}

/*
IserverContractConidInfoAndRulesGet Info and Rules

Returns both contract info and rules from a single endpoint.
For only contract rules, use the endpoint /iserver/contract/rules.
For only contract info, use the endpoint /iserver/contract/{conid}/info.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param conid IBKR contract identifier
	@return ContractAPIIserverContractConidInfoAndRulesGetRequest
*/
func (a *ContractAPIService) IserverContractConidInfoAndRulesGet(ctx context.Context, conid string) ContractAPIIserverContractConidInfoAndRulesGetRequest {
	return ContractAPIIserverContractConidInfoAndRulesGetRequest{
		ApiService: a,
		ctx:        ctx,
		conid:      conid,
	}
}

// Execute executes the request
//
//	@return IserverContractConidInfoAndRulesGet200Response
func (a *ContractAPIService) IserverContractConidInfoAndRulesGetExecute(r ContractAPIIserverContractConidInfoAndRulesGetRequest) (*IserverContractConidInfoAndRulesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IserverContractConidInfoAndRulesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractAPIService.IserverContractConidInfoAndRulesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iserver/contract/{conid}/info-and-rules"
	localVarPath = strings.Replace(localVarPath, "{"+"conid"+"}", url.PathEscape(parameterValueToString(r.conid, "conid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.isBuy == nil {
		return localVarReturnValue, nil, reportError("isBuy is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "isBuy", r.isBuy, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ContractAPIIserverContractConidInfoGetRequest struct {
	ctx        context.Context
	ApiService *ContractAPIService
	conid      string
}

func (r ContractAPIIserverContractConidInfoGetRequest) Execute() (*Contract, *http.Response, error) {
	return r.ApiService.IserverContractConidInfoGetExecute(r)
}

/*
IserverContractConidInfoGet Contract Details

Using the Contract Identifier get contract info. You can use this to prefill your order before you submit an order

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param conid contract id
	@return ContractAPIIserverContractConidInfoGetRequest
*/
func (a *ContractAPIService) IserverContractConidInfoGet(ctx context.Context, conid string) ContractAPIIserverContractConidInfoGetRequest {
	return ContractAPIIserverContractConidInfoGetRequest{
		ApiService: a,
		ctx:        ctx,
		conid:      conid,
	}
}

// Execute executes the request
//
//	@return Contract
func (a *ContractAPIService) IserverContractConidInfoGetExecute(r ContractAPIIserverContractConidInfoGetRequest) (*Contract, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Contract
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractAPIService.IserverContractConidInfoGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iserver/contract/{conid}/info"
	localVarPath = strings.Replace(localVarPath, "{"+"conid"+"}", url.PathEscape(parameterValueToString(r.conid, "conid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ContractAPIIserverContractRulesPostRequest struct {
	ctx        context.Context
	ApiService *ContractAPIService
	conid      *IserverContractRulesPostRequest
}

func (r ContractAPIIserverContractRulesPostRequest) Conid(conid IserverContractRulesPostRequest) ContractAPIIserverContractRulesPostRequest {
	r.conid = &conid
	return r
}

func (r ContractAPIIserverContractRulesPostRequest) Execute() (*IserverContractRulesPost200Response, *http.Response, error) {
	return r.ApiService.IserverContractRulesPostExecute(r)
}

/*
IserverContractRulesPost Contract Rules

Returns trading related rules for a specific contract and side. For both contract info and rules use the endpoint /iserver/contract/{conid}/info-and-rules.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ContractAPIIserverContractRulesPostRequest
*/
func (a *ContractAPIService) IserverContractRulesPost(ctx context.Context) ContractAPIIserverContractRulesPostRequest {
	return ContractAPIIserverContractRulesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return IserverContractRulesPost200Response
func (a *ContractAPIService) IserverContractRulesPostExecute(r ContractAPIIserverContractRulesPostRequest) (*IserverContractRulesPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IserverContractRulesPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractAPIService.IserverContractRulesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iserver/contract/rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conid == nil {
		return localVarReturnValue, nil, reportError("conid is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.conid
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ContractAPIIserverSecdefInfoGetRequest struct {
	ctx        context.Context
	ApiService *ContractAPIService
	conid      *string
	sectype    *string
	month      *string
	exchange   *string
	strike     *float32
	right      *string
}

// underlying contract id
func (r ContractAPIIserverSecdefInfoGetRequest) Conid(conid string) ContractAPIIserverSecdefInfoGetRequest {
	r.conid = &conid
	return r
}

// FUT/OPT/WAR/CASH/CFD
func (r ContractAPIIserverSecdefInfoGetRequest) Sectype(sectype string) ContractAPIIserverSecdefInfoGetRequest {
	r.sectype = &sectype
	return r
}

// contract month, only required for FUT/OPT/WAR in the format MMMYY, example JAN00
func (r ContractAPIIserverSecdefInfoGetRequest) Month(month string) ContractAPIIserverSecdefInfoGetRequest {
	r.month = &month
	return r
}

// optional, default is SMART
func (r ContractAPIIserverSecdefInfoGetRequest) Exchange(exchange string) ContractAPIIserverSecdefInfoGetRequest {
	r.exchange = &exchange
	return r
}

// optional, only required for OPT/WAR
func (r ContractAPIIserverSecdefInfoGetRequest) Strike(strike float32) ContractAPIIserverSecdefInfoGetRequest {
	r.strike = &strike
	return r
}

// C for call, P for put
func (r ContractAPIIserverSecdefInfoGetRequest) Right(right string) ContractAPIIserverSecdefInfoGetRequest {
	r.right = &right
	return r
}

func (r ContractAPIIserverSecdefInfoGetRequest) Execute() ([]SecdefInfo, *http.Response, error) {
	return r.ApiService.IserverSecdefInfoGetExecute(r)
}

/*
IserverSecdefInfoGet Secdef Info

Provides Contract Details of Futures, Options, Warrants, Cash and CFDs based on conid. To get the strike price for Options/Warrants use "/iserver/secdef/strikes" endpoint. Must call /secdef/search for the underlying contract first.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ContractAPIIserverSecdefInfoGetRequest
*/
func (a *ContractAPIService) IserverSecdefInfoGet(ctx context.Context) ContractAPIIserverSecdefInfoGetRequest {
	return ContractAPIIserverSecdefInfoGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []SecdefInfo
func (a *ContractAPIService) IserverSecdefInfoGetExecute(r ContractAPIIserverSecdefInfoGetRequest) ([]SecdefInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []SecdefInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractAPIService.IserverSecdefInfoGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iserver/secdef/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conid == nil {
		return localVarReturnValue, nil, reportError("conid is required and must be specified")
	}
	if r.sectype == nil {
		return localVarReturnValue, nil, reportError("sectype is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "conid", r.conid, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "sectype", r.sectype, "")
	if r.month != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "month", r.month, "")
	}
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "")
	}
	if r.strike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strike", r.strike, "")
	}
	if r.right != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "right", r.right, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetFutures500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ContractAPIIserverSecdefStrikesGetRequest struct {
	ctx        context.Context
	ApiService *ContractAPIService
	conid      *string
	sectype    *string
	month      *string
	exchange   *string
}

// contract id of the underlying contract
func (r ContractAPIIserverSecdefStrikesGetRequest) Conid(conid string) ContractAPIIserverSecdefStrikesGetRequest {
	r.conid = &conid
	return r
}

// OPT/WAR
func (r ContractAPIIserverSecdefStrikesGetRequest) Sectype(sectype string) ContractAPIIserverSecdefStrikesGetRequest {
	r.sectype = &sectype
	return r
}

// contract month
func (r ContractAPIIserverSecdefStrikesGetRequest) Month(month string) ContractAPIIserverSecdefStrikesGetRequest {
	r.month = &month
	return r
}

// optional, default is SMART
func (r ContractAPIIserverSecdefStrikesGetRequest) Exchange(exchange string) ContractAPIIserverSecdefStrikesGetRequest {
	r.exchange = &exchange
	return r
}

func (r ContractAPIIserverSecdefStrikesGetRequest) Execute() (*IserverSecdefStrikesGet200Response, *http.Response, error) {
	return r.ApiService.IserverSecdefStrikesGetExecute(r)
}

/*
IserverSecdefStrikesGet Search Strikes

Query strikes for Options/Warrants. For the conid of the underlying contract, available contract months and exchanges use "/iserver/secdef/search"

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ContractAPIIserverSecdefStrikesGetRequest
*/
func (a *ContractAPIService) IserverSecdefStrikesGet(ctx context.Context) ContractAPIIserverSecdefStrikesGetRequest {
	return ContractAPIIserverSecdefStrikesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return IserverSecdefStrikesGet200Response
func (a *ContractAPIService) IserverSecdefStrikesGetExecute(r ContractAPIIserverSecdefStrikesGetRequest) (*IserverSecdefStrikesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IserverSecdefStrikesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractAPIService.IserverSecdefStrikesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iserver/secdef/strikes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conid == nil {
		return localVarReturnValue, nil, reportError("conid is required and must be specified")
	}
	if r.sectype == nil {
		return localVarReturnValue, nil, reportError("sectype is required and must be specified")
	}
	if r.month == nil {
		return localVarReturnValue, nil, reportError("month is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "conid", r.conid, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "sectype", r.sectype, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "month", r.month, "")
	if r.exchange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchange", r.exchange, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetFutures500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ContractAPISearchBySymbolOrNameRequest struct {
	ctx        context.Context
	ApiService *ContractAPIService
	symbol     *SearchBySymbolOrNameRequest
}

// Symbol or Company Name to be searched
func (r ContractAPISearchBySymbolOrNameRequest) Symbol(symbol SearchBySymbolOrNameRequest) ContractAPISearchBySymbolOrNameRequest {
	r.symbol = &symbol
	return r
}

func (r ContractAPISearchBySymbolOrNameRequest) Execute() ([]SearchBySymbolOrName200ResponseInner, *http.Response, error) {
	return r.ApiService.SearchBySymbolOrNameExecute(r)
}

/*
SearchBySymbolOrName Search by Symbol or Name

Search by underlying symbol or company name. Relays back what derivative contract(s) it has. This endpoint must be called before using /secdef/info.
If company name is specified will only receive limited response: conid, companyName, companyHeader and symbol.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ContractAPISearchBySymbolOrNameRequest
*/
func (a *ContractAPIService) SearchBySymbolOrName(ctx context.Context) ContractAPISearchBySymbolOrNameRequest {
	return ContractAPISearchBySymbolOrNameRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []SearchBySymbolOrName200ResponseInner
func (a *ContractAPIService) SearchBySymbolOrNameExecute(r ContractAPISearchBySymbolOrNameRequest) ([]SearchBySymbolOrName200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []SearchBySymbolOrName200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractAPIService.SearchBySymbolOrName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iserver/secdef/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.symbol
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetFutures500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
